# === Imports === #
            # elif LanRe.match(LanRe.ImportStatement, line):
            #     m = LanRe.match(LanRe.ImportStatement, line)
            #     file_name:str = m.group(1) + FILE_EXT
            #     this.echo(f"Importing from {file_name}", "Importer")
            #     function_bloc:str = m.group(2)
            #     functions = [funct.strip() for funct in function_bloc.split(",")]
            #     # Setup Vitual envirement
            #     mi = MylangeInterpreter(f"Imports\\{m.group(1)}", startBlockCacheNumber=len([item for item in this.CleanCodeCache.keys() if item.startswith("0x")]))
            #     mi.make_child_block(this)
            #     with open(file_name, 'r') as imports_file:
            #         mi.interpret(imports_file.read())
            #         for funct_name in functions:
            #             this.Booker.FunctionRegistry[funct_name] = mi.Booker.FunctionRegistry[funct_name]
            #         this.CleanCodeCache.update(mi.CleanCodeCache)
            # === Variables === #
            # elif LanRe.match(LanRe.VariableDecleration, line):
            #     m = LanRe.match(LanRe.VariableDecleration, line)
            #     this.echo(f"Beginning Variable Declaration: {line}")
            #     #globally:bool = m.group(1)=="global"
            #     typeid:int = LanTypes.from_string(m.group(2))
            #     name:str = m.group(3)
            #     #protected:bool = m.group(4).count('>') == 2
            #     value_str:str = m.group(5)
            #     #value:VariableValue = VariableValue(typeid)
            #     value = this.format_parameter(value_str)
            #     this.echo(f"This is a Variable Declaration! {name}@{typeid}({m.group(2)}) {value}", indent=1)
            #     this.Booker.set(name, value)
            # elif (LanRe.match(LanRe.VariableRedeclaration, line)):
            #     m = LanRe.match(LanRe.VariableRedeclaration, line)
            #     varname:str = m.group(1)
            #     varextention:str = m.group(2)
            #     newvalue:str = m.group(3)
            #     #print(varname, varextention, newvalue)
            #     if not this.Booker.find(varname): raise LanErrors.MemoryMissingError()
            #     fullvarname:str = varname + (varextention if (varextention != None) else "")
            #     var = this.Booker.get(fullvarname)
            #     castedvalue = this.format_parameter(newvalue)
            #     if castedvalue.typeid != var.typeid: raise LanErrors.WrongTypeExpectationError()
            #     var.value = this.format_parameter(newvalue).value
            # === If/Else ===#
            # elif LanRe.match(LanRe.IfStatementGeneral, line):
            #     # Match to correct if/else block
            #     condition = None
            #     when_true = None 
            #     when_false = None
            #     if LanRe.match(LanRe.IfElseStatement, line):
            #         m = LanRe.match(LanRe.IfElseStatement, line)
            #         condition = m.group(1)
            #         when_true = m.group(2)
            #         when_false = m.group(3)
            #     elif LanRe.match(LanRe.IfStatement, line):
            #         m = LanRe.match(LanRe.IfStatement, line)
            #         condition = m.group(1)
            #         when_true = m.group(2)
            #     else:
            #         raise Exception("IF/Else statement not configured right!")
            #     this.echo(f"Parts: {when_true}, {when_false}, {condition}", indent=1)
            #     # Evaluate the statement
            #     result = (this.format_parameter(condition)).value
            #     if type(result) != bool:
            #         raise LanErrors.ConditionalNotBoolError(f"Cannot use this for boolean logic ({type(result)} {result}): {condition}")
            #     # Do functions
            #     if (result):
            #         block = MylangeInterpreter(f"{this.BlockTree}/IfTrue", this.LineNumber)
            #         block.make_child_block(this, True)
            #         block.interpret(when_true, True)
            #     elif (not result) and (when_false!=None):
            #         block = MylangeInterpreter(f"{this.BlockTree}/IfFalse", this.LineNumber)
            #         block.make_child_block(this, True)
            #         block.interpret(when_false, True)
            # === Function Declaration === #
            # elif LanRe.match(LanRe.FunctionStatement, line):
            #     m = LanRe.match(LanRe.FunctionStatement, line)
            #     return_type:str = m.group(1)
            #     function_name:str = m.group(2)
            #     function_parameters_string = m.group(3)
            #     function_code_string = m.group(4)
            #     funct = LanFunction(function_name, return_type, function_parameters_string, function_code_string)
            #     this.Booker.FunctionRegistry[function_name] = funct
            # === Class Declaration === #
            # elif LanRe.match(LanRe.ClassStatement, line):
            #     m = LanRe.match(LanRe.ClassStatement, line)
            #     cls_name:str = m.group(1)
            #     cls_body:str = m.group(2)
            #     lan_cls = LanClass(cls_name, cls_body, this)
            #     this.Booker.ClassRegistry[cls_name] = lan_cls
            # === Class Property Set === #
            # elif LanRe.match(LanRe.PropertySetStatement, line):
            #     m = LanRe.match(LanRe.PropertySetStatement, line)
            #     objectMethodMaster.Properties[m.group(1)] = this.format_parameter(m.group(2))
            # === Loops === #
            # elif LanRe.match(LanRe.ForStatement, line):
            #     m = LanRe.match(LanRe.ForStatement, line)
            #     loop_var = f"{m.group(1).strip()} {m.group(2).strip()}"
            #     loop_over:list[VariableValue] = this.format_parameter(m.group(3)).value
            #     loop_do_str:str = m.group(4)
            #     loop_funct = LanFunction("ForLoop", "nil", loop_var, loop_do_str)
            #     try:
            #         for item in loop_over: loop_funct.execute(this, [item], True)
            #     except LanErrors.Break: pass
            # elif LanRe.match(LanRe.WhileStatement, line):
            #     while_m = LanRe.match(LanRe.WhileStatement, line)
            #     while_condition = while_m.group(1).strip()
            #     while_do_str = while_m.group(2).strip()
            #     while_loop_funct = LanFunction("WhileLoop", "nil", "", while_do_str)
            #     try:
            #         while this.format_parameter(while_condition).value:
            #             while_loop_funct.execute(this, [], True)
            #     except LanErrors.Break: pass
            # === Other === #
            # elif LanRe.match(LanRe.FunctionOrMethodCall, line):
            #     this.do_function_or_method(line)
            # elif LanRe.match(LanRe.CachedBlock, line):
            #     r = this.interpret(this.CleanCodeCache[line.strip()], True)
            #     if (r != None): Return = r
            # elif LanRe.match(LanRe.BreakStatement, line):
            #     this.echo("Break Called")
            #     raise LanErrors.Break()
            # elif LanRe.match(LanRe.ReturnStatement, line):
            #     # Last thing, return forced
            #     m = LanRe.match(LanRe.ReturnStatement, line)
            #     Return = this.format_parameter(m.group(1))
            #     return Return